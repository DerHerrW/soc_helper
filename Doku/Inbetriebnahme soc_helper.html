<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Inbetriebnahme soc_helper</title>
  </head>
  <body>
    <h1><a id="mozTocId505102" class="mozTocH1"></a>wican, soc_helper und
      OpenWB: Konfiguration und Inbetriebnahme</h1>
    <p>Der soc_helper hat den Zweck, den Ladezustand und Kilometerstand eines
      Elektrofahrzeugs auszulesen und die OpenWB zu übertragen.</p>
    <h2><a id="mozTocId955068" class="mozTocH2"></a>Warum?</h2>
    <p>Die OpenWB bietet die Möglichkeit, nur bis zu einem bestimmten
      Ladezustand zu laden. Auch kann in Abhängigkeit vom Ladezustand des
      Fahrzeugs auf verschiedene Weise geladen werden. So kann beispielsweise
      ein maximaler Ladezustand (SOC) von 80% definiert werden, um die
      Fahrzeugbatterie zu schonen. Oder es kann direkt nach Anstecken bis zu
      einem Mindestfüllstand geladen werden, darüber hinaus per PV-Überschuß und
      dann zu bis zu einer definierten Uhrzeit bis zu einer Grenze. Alles das
      setzt voraus, daß der Ladezustand der Wallbox bekannt ist.</p>
    <p>Um den Ladezustand in die Wallbox zu bekommen, bietet diese ab Werk schon
      verschiedene Möglichkeiten. So kann für eine Anzahl von Fahrzeugen beim
      Laden periodisch die Hersteller-Cloud abgefragt werden. Eine andere
      Möglichkeit ist, einen MQTT-Client periodisch einen SOC-Wert in die
      Wallbox schreiben zu lassen. Der einfachste Weg ist, vor dem Stecken des
      Ladesteckers manuell (am Handy oder Wallbox-Display) den Ladezustand
      einzugeben - anhand derhinterlegten Batteriekapazität und des
      Ladewirkungsgrades sowie der durchgesetzen elektrischen Arbeit kann die
      OpenWB den aktuellen Ladezustand des Fahrzeugs berechnen. </p>
    <p>Der soc_helper kommt da ins Spiel, wo kein passendes Fahrzeug-Modul
      vorhanden ist oder man die Hersteller-Cloud nicht nutzen oder bezahlen
      möchte: Der WiCAN ist ein Dongle für die Diagnosebuche von
      Kraftfahrzeugen. Er bietet die Möglichkeit, sich in ein WLAN einzubuchen
      und mit einem erreichbaren MQTT-Broker zu kommunizieren. Wenn der WiCAN
      eingebucht und mit einem MQTT-Broker verbunden ist, kann per MQTT eine
      Anforderung über den WiCAN und die Diagnosebuchse an das Fahrzeug gestellt
      werden. Das Fahrzeug beantwortet eine gültige Anfrage, was vom WiCAN
      wiederum per MQTT bekannt gegeben wird.</p>
    <p>Der soc_helper läuft auf einem beliebigen python-fähigen Rechner im
      Heimnetz und stellt die Verbindung zwischen WiCAN und OpenWB her. Sobald
      der WiCAN sich in den MQTT-Broker der OpenWB eingebucht hat, schickt der
      soc_helper Abfragen von Kilometerstand und Ladezustand ab. Die Antworten
      des Fahrzeugs werden ausgewertet. Der Ladezustand wird in die OpenWB
      übertragen und dient der oben erwähnten Ladesteuerung.Durch die
      zusätzliche Abfrage des Kilometerstandes kann auf Wunsch mit Spritmonitor
      über den Verbrauch Protokoll geführt werden. </p>
    <h2><a id="mozTocId271714" class="mozTocH2"></a>Große Umbaumaßnamen ab
      Version 2024-0x-yy</h2>
    <p>Mit der Version 2024-xx-yy wurde der soc_helper erheblich überarbeitet.
      Die Konfiguration für Anwender ist erheblich vereinfacht, da die
      fahrzeugspezifischen Teile in die Datei cars.py gezogen sind, und nur noch
      ein Minimum an Parametern in der Konfigurationsdatei configuration.py
      vorhanden ist. Dafür gibt es jetzt die Möglichkeit, beliebig viele Autos
      mit WiCAN-Adapter mit einem System von beliebig vielen Ladepunkten an
      einem OpenWB-System zu betreiben.</p>
    <p>Die OpenWB-Software 1.9 wird nicht mehr unterstützt.</p>
    <h1><a id="mozTocId604144" class="mozTocH1"></a>Anleitung</h1>
    <p>Die hier vorliegenden Dokumente sollen eine Schritt-für-Schritt-Anleitung
      zum erfolgreichen Betrieb des soc_helper geben. Für die Anleitung wird
      angenommen, daß ein aktuelles Raspberry-Pi-System mit raspian verwendet
      wird. Auf anderen Rechnern funktioniert die Prozedur ähnlich,
      möglicherweise unterscheiden sich aber einzelne Schritte. Die
      Konfiguration umfasst Folgendes:</p>
    <ol id="mozToc">
      <!--mozToc h1 1 h2 2-->
      <li><a href="#mozTocId505102">wican, soc_helper und OpenWB: Konfiguration
          und Inbetriebnahme</a>
        <ol>
          <li><a href="#mozTocId955068">Warum?</a></li>
          <li><a href="#mozTocId271714">Große Umbaumaßnamen ab Version
              2024-0x-yy</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId604144">Anleitung</a></li>
      <li><a href="#mozTocId772571">WiCAN konfigurieren</a>
        <ol>
          <li><a href="#mozTocId35783">WiCAN ins eigene WLAN holen</a></li>
          <li><a href="#mozTocId912680">Firmware aktualisieren</a></li>
          <li><a href="#mozTocId822299">Restliche Konfiguration</a></li>
          <li><a href="#mozTocId813201">Prüfen der vom WiCAN gemessenen
              Batteriespannung</a></li>
          <li><a href="#mozTocId916932">Prüfen des Schlafmodus des WiCAN</a></li>
          <li><a href="#mozTocId688561">Micro-SD-Karte bespielen:</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId627679">Nur Einmalig: Installieren der benötigten
          python-Pakete</a></li>
      <li><a href="#mozTocId102185">soc_helper aufspielen</a></li>
      <li><a href="#mozTocId731150">Optional: Vorbereitung für Spritmonitor</a>
        <ol>
          <li><a href="#mozTocId592205">Spritmonitor-Zugang verschaffen und
              Fahrzeug anlegen</a></li>
          <li><a href="#mozTocId155224">Bearer-Token beschaffen und sichern</a></li>
          <li><a href="#mozTocId723519">Bearer-Token als Umgebungsvariable
              bereitstellen</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId997138">OpenWB vorbereiten</a>
        <ol>
          <li><a href="#mozTocId676866">Fahrzeugprofile</a></li>
          <li><a href="#mozTocId955155">Fahrzeuge</a></li>
          <li><a href="#mozTocId504076">Geräte-IDs herausfinden und merken</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId36262">soc_helper konfigurieren</a>
        <ol>
          <li><a href="#mozTocId230049">Anlegen der Fahrzeuge</a></li>
          <li><a href="#mozTocId304700">Anlegen der Ladepunkte</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId347587">soc_helper starten und stoppen</a>
        <ol>
          <li><a href="#mozTocId985445">Programm im Vordergrund starten und
              stoppen</a></li>
          <li><a href="#mozTocId156538">Programm im Hintergrund laufen lassen</a></li>
          <li><a href="#mozTocId104512">Stoppen eines nicht im Hintergrund
              laufenden soc_helper</a></li>
          <li><a href="#mozTocId134662">Stoppen eines im Hintergrund laufenden
              soc_helper</a></li>
          <li><a href="#mozTocId533403">Optional: Starten des soc_helpers mit
              Start des System</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId385913">Hinzufügen neuer Fahrzeugtypen</a>
        <ol>
          <li><a href="#mozTocId570147">SOC-Abfrage</a></li>
          <li><a href="#mozTocId44611">Kilometerstand-Abfrage</a></li>
          <li><a href="#mozTocId395377">SOC-Berechnung</a></li>
          <li><a href="#mozTocId299402">Kilometerstand-Berechnung</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId979530">Optional, aber hilfreich: MQTT-Explorer auf
          Desktop installieren</a>
        <ol>
          <li><a href="#mozTocId797585">Oberfläche</a></li>
          <li><a href="#mozTocId440211">Nutzen des MQTT-Explorers zur
              Fehlersuche</a></li>
        </ol>
      </li>
    </ol>
    <br>
    <h1><a id="mozTocId772571" class="mozTocH1"></a>WiCAN konfigurieren </h1>
    <h2><a id="mozTocId35783" class="mozTocH2"></a> WiCAN ins eigene WLAN holen</h2>
    <p>Der WiCAN hat ein nützliches Feature: Er kann so konfiguriert werden, daß
      er aus dem Heimnetz erreichbar ist. So könnte theoretisch vom heimischen
      Rechner aus der OBD-Port des Fahrzeugs abgefragt werden. (Die App "Car
      Scanner" kann das auch)</p>
    Ein neuer WiCAN bucht sich natürlich noch nicht in das heimische WLAN ein.
    Er spannt ein offenes WLAN mit dem Namen "WiCAN_xxxxxxxxxxxx" auf (die x
    stehen für die 12 Ziffern der Seriennummer). Nach Einstecken des WiCAN
    sollte das Netzwerk in der WLAN-Suche des Smartphones oder Laptops
    auftauchen. Das Smartphone / der Laptop soll sich mit diesem WLAN verbinden.
    Beim Verbinden ist das Standard-Passwort "@meatpi#" eingeben.
    <p>Mit dem Browser kann der Dongle jetzt unter <a href="http://192.168.80.1%20">http://192.168.80.1</a>
      erreicht werden, sofern der Rechner ins WiCAN-WLAN eingebucht ist. Wichtig
      ist, dass kein "s" im "http" ist - Firefox setzt das automatisch!</p>
    <p>Unter dem Reiter "Settings" muß zunächst das WLAN konfiguriert werden.
      Wichtige Einstellungen:</p>
    <ul>
      <li>AP Config: Mode: AP+Station</li>
      <li>Station Config: SSID: Name des Heimnetzes eingeben</li>
      <li>Station Config: Passwort: Kennwort des Heimnetzes eingeben</li>
    </ul>
    <p>Unten den Knopf "Submit Changes" betätigen. Nach dem darauf folgenden
      Neustart sollte der WiCAN als Gerät im Heimnetzwerk auftauchen.Die
      IP-Adresse läßt sich im heimischen Router finden, bei der Fritz!Box unter
      Heimnetz-&gt;Heimnetzübersicht, Reiter Netzwerkverbindungen. Die folgenden
      Einstellungen erfolgen nach Aufruf der dort gelisteten IP-Adresse. Auch
      hier ist wieder wichtig, daß kein "s" hinter "http" vorhanden ist. Firefox
      setzt dieses automatisch, es muß dann per Hand entfernt werden.</p>
    <p>Anmerkung: Meiner Erfahrung nach werden alle Einstellungen des WiCAN auf
      Werkseinstellung zurückgesetzt, wenn man sich über das WiCAN-eigene WLAN
      mit dem WiCAN verbindet. Nachdem der WiCAN im Heimnetz ist, sollte also
      nicht mehr in das vom WiCAN aufgespannte WLAN eingebucht werden!</p>
    <h2><a id="mozTocId912680" class="mozTocH2"></a>Firmware aktualisieren<br>
    </h2>
    <p>Falls der WiCAN noch nicht mit Firmware 2.98 oder neuer läuft, ist ein
      Updateder Firmware erforderlich: Ab Version 2.98 ist es möglich, den Zweig
      der WiCAN-Topics im WiCAN vorzugeben. Dies ist nötig, damit das System mit
      der OpenWB-Software 2.1.4 oder neuer zusammen funktioniert.</p>
    <h3><a id="mozTocId359654" class="mozTocH3"></a>Firmware herunterladen und
      auspacken</h3>
    <p>Die aktuelle Firmware wird hier herunterladen: <a href="Der%20Name%20folgt%20dem%20Schema%20%22wican-fw-vXXX_hv300.bin%22.">https://github.com/meatpiHQ/wican-fw/releases/</a>
    </p>
    <p>Der Name folgt dem Schema "wican-fw-vXXX_hv300.bin". Bitte das Archiv <b>ohne
        den Namensbestandteil "usb"</b> wählen!</p>
    <p>Das Archiv<b> auf dem Heimrechner auspacken</b> und <b>den Speicherort
        merken</b>.</p>
    <h3><a id="mozTocId825644" class="mozTocH3"></a>Firmware flashen</h3>
    <p>Nach Aufruf der WiCAN-Seite im Browser (siehe "<a href="#mozTocId35783">WiCAN
        ins eigene WLAN holen</a>") befindet sich die Updatemöglichkeit ist auf
      dem Reiter "About":</p>
    <p><br>
    </p>
    <p><img src="Firmwareupdate.png" alt="Die Möglichkeit zum Firmwareupdate befindet sich in der WiCAN-Oberfläche unter dem Reiter &quot;About&quot;"
        title="Firmwareupdate im About-Reiter"></p>
    <ol>
      <li>Nach Klick auf "Browser..." wird im sich öffnenden Dateiauswahlmenü
        die wie oben beschrieben aktuelle entpackte Firmwaredatei im .bin-Format
        ausgewählt. Es handelt sich dabei um die größte der vier bin-Dateien im
        Archiv. Der Name folgt dem Schema "wican-fw-vXXX_hv300.bin".</li>
      <li>Ein Klick auf "Update" lädt die Datei auf den WiCAN hoch und führt das
        Update durch. </li>
      <li>Falls der WiCAN nach dem Neustart nicht mehr im Heimnetz erreichbar
        ist, sind die Einstellungen wieder zurückgesetzt worden. In diesem Fall
        den Konfigurationsschritt <a href="#mozTocId35783">(WiCAN ins eigene
          WLAN holen</a>) bitte erneut ausführen.</li>
    </ol>
    <h2><a id="mozTocId822299" class="mozTocH2"></a>Restliche Konfiguration </h2>
    <p>Die gesamte Konfiguration ist der Abbildung zu entnehmen:</p>
    <p><img src="Settings.png" alt="fsdfsd" title="Einstellungen gesamt"></p>
    <p>Dazu folgende Anmerkungen:</p>
    <ul>
      <li>MQTT muss auf Enable stehen, damit der WiCAN per MQTT erreichbar ist
        und Daten abgeben kann.</li>
      <li>Sleep sollte auf Enable stehen, damit der WiCAN sich schlafen legt und
        die Niedervoltbatterie nicht belastet.</li>
      <li>Sleep Voltage ist die Schwelle der Bordnetzspannung, unterhalb der der
        WiCAN nach etwa drei Minuten schlafen geht. Diese Schwelle sollte höher
        liegen als die Ruhespannung der voll geladenen Niedervoltbatterie (etwa
        13,2V) aber niedriger als die Spannung beim Laden der Batterie im
        Zustand Fahrbereitschaft (z.B. 14,7V). Auf diese Weise wacht das Gerät
        auf, nachdem Fahrbereitschaft hergestellt wird und die
        Niedervoltbatterie geladen wird. Nach Ende der Ladung und Ablauf der
        Verzögerungszeit legt sich der WiCAN wieder schlafen.</li>
      <li>Battery Alert sollte auf Disable stehen, hier besteht die Möglichkeit,
        daß der WiCAN bei Unterschreiten einer Spannungsschwelle aufwacht und
        per MQTT eine Alarmbotschaft verschickt. Dieses Feature wird vom
        soc_helper nicht genutzt.</li>
      <li>MQTT URL muss die IP-Adresse beinhalten, unter der die OpenWB
        erreichbar ist.</li>
      <li>MQTT Usernd Passwort <b>müssen leer bleiben</b> (bis Software 2.1.3
        der OpenWB war der Inhalt beliebig).</li>
      <li>TX, RX, Status Topic: Dies sind die Zweige, unter denen der WiCAN
        seine Informationen empfängt und veröffentlicht. Wenn er aktiv oder
        inaktiv wird und sich ins WLAN einbucht oder abmeldet, schreibt er eine
        Statusbotschaft an den unter URL definierten MQTT-Broker. Desgleichen
        lauscht er auf dem RX Topic auf Botschaften und sendet Informationen auf
        dem TX Topic. In Version 2.1.4 der OpenWB sind alle Topics bis auf
        einige set-Topics unbeschreibbar. Dies schützt vor versehentlichem
        Überschreiben der Wallbox-Konfiguration. Für Fremdnutzung ist ab der
        Software 2024-05-28 im Masterzweig der Zweig others/ vorgesehen. Die in
        der Abbildung angegebenen Zweige sind einzuhalten, der Teil "nulli" ist
        dabei frei wählbar - zum Beispiel der Fahrzeugname - und muß in die
        Konfigurationsdatei configuration.py übernommen werden. Die Gesamtlänge
        der Topics darf jeweils 64 Zeichen nicht überschreiten.</li>
      <li>MQTT elm327 log: Sollte auf Disable stehen bleiben. Ansonsten kann man
        mit dem weiter unten stehenden Filter CAN-Botschaften der
        OBD-Schnittstelle definierten, die automatisiert umgerechnet und an den
        Broker geschickt werden. Im Fall soc_helper passiert dies aber nicht auf
        dem WiCAN.<br>
      </li>
    </ul>
    <br>
    <h2><a id="mozTocId813201" class="mozTocH2"></a>Prüfen der vom WiCAN
      gemessenen Batteriespannung</h2>
    <p>Unter dem Reiter "Status" des WiCAN ist die gemessene Bordnetzspannung zu
      sehen. Bei eingeschalteter Hochvolt-Batterie (Fahrbereitschaft) sollten
      über 13.8V und unter 15V zu sehen sein. Bei abgeschalteter
      Hochvolt-Batterie sollte die Spannung unter 13,5V fallen. Stehen hier
      doppelt so hohe Werte, wurde die falsche Firmware geflasht (die mit "usb"
      im Namen).&nbsp; Dann bitte nochmal die richtige Firmware flashen.</p>
    <h2><a id="mozTocId916932" class="mozTocH2"></a>Prüfen des Schlafmodus des
      WiCAN</h2>
    <p>Der WiCAN sollte sich einige Zeit nach Wegnahme der Fahrbereitschaft des
      Fahrzeugs schlafen legen, um die Niedervolt-Batterie zu schonen. Diesist
      der Fall, wenn die WiCAN-Seite im Heimnetz nach einigen Minuten nicht mehr
      erreichbar ist.</p>
    <h3><a id="mozTocId197373" class="mozTocH3"></a>Hilfreiche Links: </h3>
    <p>Anleitung: <a href="Anleitung:%20https://github.com/meatpiHQ/wican-fw">https://github.com/meatpiHQ/wican-fw</a></p>
    <p><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a></p>
    Linuxsystem konfigurieren Vorweg: Es ist nicht nötig, Linux als Grundlage
    für den soc_helper zu verwenden. Theoretisch kann auch ein Desktoprechner
    oder Laptop mit Windows verwendet werden. Empfehlenswert ist allerdings
    etwas stromsparendes wie der Raspberry Pi. Weil ich mit Windows keine
    Erfahrungen habe, beschreibe ich hier die nötigen Tätigkeiten nach dem
    Aufsetzen eines Linux-Grundsystems auf einem Raspberry Pi. Für die Bedienung
    eines Linux-Systems von der Konsole sei auf andere Anleitungen verwiesen, da
    dies den Umfang dieser Anleitung bei weitem sprengen würde.<br>
    <h2><a id="mozTocId688561" class="mozTocH2"></a>Micro-SD-Karte bespielen:</h2>
    <p>Für die Installation von Raspbian sei auf folgende Seite verwiesen:</p>
    <p>Anleitung und Einführung in Raspbian: <a href="https://www.raspberrypi.com/documentation/computers/getting-started.html">https://www.raspberrypi.com/documentation/computers/getting-started.html</a>,</p>
    <p>darunter das Beschreiben einer Micro-SD-Karte mit Raspbian: <a href="https://www.raspberrypi.com/documentation/computers/getting-started.html#install-an-operating-system">https://www.raspberrypi.com/documentation/computers/getting-started.html#install-an-operating-system</a></p>
    <p>Es sollte ein minimales System (Raspian Lite) gewählt werden, da eine
      grafische Nutzeroberfläche nicht nötig ist. Die 64-Bit-Version sollte nur
      für die neueren Raspberries verwendet werden, den RPi4, 5 und 400. Alle
      anderen benötigen ein 32-Bit-System.</p>
    <p>Bei der Installation oder beim ersten Start werden verschiedene Dinge
      abgefragt wie WLAN-Zugang (sofern gewünscht), Nutzername und Passwort,
      Lokalisierung. Wichtig bei der Konfiguration ist, daß<b> "Enable ssh" </b>angewählt
      wird. Damit ist später ein Betrieb ohne Monitor und Tastatur und eine
      Bedienung per Fernzugriff möglich. </p>
    <p>Um später Änderungen in der Konfiguration von raspian durchzuführen,
      existiert das Kommando</p>
    <p><code>sudo raspi-config,</code></p>
    <code></code>das nach dem Anmelden am System eingegeben wird.<br>
    <h1><a id="mozTocId627679" class="mozTocH1"></a>Nur Einmalig: Installieren
      der benötigten python-Pakete</h1>
    <p>soc_helper benötigt ein paar Python-Bibliotheks-Pakete, um korrekt zu
      funktionieren. Diese müssen einmalig nachinstalliert werden. Nach dem
      Anmelden per ssh auf dem Pi&nbsp; erfolgt dies mit dem Befehl:</p>
    <p><code>sudo apt install python3-paho-mqtt python3-watchdog
        python3-requests<br>
      </code></p>
    <p>Damit ist das Grundsystem konfiguriert.</p>
    <p><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a></p>
    <h1><a id="mozTocId102185" class="mozTocH1"></a>soc_helper aufspielen</h1>
    <p>Voraussetzung ist, daß der Raspberry Pi hochgefahren und die
      Erstkonfiguration erfolgt ist sowie der ssh-Zugang aktiviert ist. Die
      Adresse des Raspberries kann im Heimrouter gefunden werden. Wenn Tastatur
      und Monitor verbunden sind, kann nach Anmeldung mit dem Befehl "ifconfig"
      die Adresse angezeigt werden. Im Folgenden wird davon ausgegangen, daß ein
      Nutzer "pi" angelegt wurde und der Raspi den Namen <i>socke</i> die
      interne IP-Adresse 192.168.178.111 hat. </p>
    <p>Mit einem geeigneten Dateiverwaltungs-Tool kann auf den Raspi zugegriffen
      werden. Dazu wird als Adresse <span style="font-family: monospace;">sftp://pi@192.168.178.111/home/pi/</span>
      oder <code><i>sftp://pi@socke</i></code> angegeben. Nach Abfrage des
      Passwortes des Nutzers sollte der Inhalte des Homeverzeichnisses zu sehen
      sein. (Unter Windows kann möglicherweise winscp genutzt werden: <a href="https://winscp.net/eng/docs/lang:de">https://winscp.net/eng/docs/lang:de</a>.
      Unter Linux können beispielsweise nautilus und dolphin mit ssh umgehen.)</p>
    <p>Das heruntergeladene zip-Archiv des soc_helper wird nun auf dem
      Desktop-Rechner entpackt und der Ordner soc_helper samt Inhalt per
      Dateiverwaltung in das Nutzerverzeichnis (/home/pi) auf den Raspi kopiert.
    </p>
    <p><b>Fallstrick:</b> Sollte sich bereits ein funktionierender&nbsp;
      soc_helper auf dem Zielsystem befinden, sollte vor dem Kopiervorgang die
      Konfigurationsdatei configuration.py gesichert werden, zum Beispiel durch
      Kopieren in configuration.py.funktioniert. Es empfiehlt sich beim jetzigen
      Entwicklungsstand, bei jeder neuen Version die mitgelieferte Konfiguration
      mit Hilfe der gesicherten configuration.py an die eigenen Bedürfnisse
      anzupassen, da sich das Format häufiger ändern kann. </p>
    <p><b>Fallstrick 2</b>: Wenn das Archiv auf einem Windows-Rechner entpackt
      wurde, werden die Dateiattribute nicht gespeichert. Diese entscheiden
      unter Unix (und Linux), ob eine Datei lesbar / schreibar / ausführbar ist
      und für wen. In diesem Fall empfiehlt es sich nach dem Kopieren auf den
      Raspberry, die Datei soc_helper.py per Hand ausführbar zu machen, um sie
      direkt aufrufen zu können. Das geschieht nach dem Wechsel in das
      Verzeichnis soc_helper mit dem Befehl <code>chmod 755 soc_helper.py</code>.
      Siehe hierzu auch die <a href="https://wiki.ubuntuusers.de/chmod/" target="_blank">Erklärung
        von ubuntu zu chmod.</a></p>
    <p><br>
    </p>
    <p><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a></p>
    <p></p>
    <h1><a id="mozTocId731150" class="mozTocH1"></a>Optional: Vorbereitung für
      Spritmonitor</h1>
    <p>Die Nutzung von Spritmonitor ist optional und zur Zeit der Dokumentation
      kostenlos. Spritmonitor ist eine große Datenbank von Verbräuchen, die von
      den Nutzern eingepflegt wird. Man kann dort sehen, welche Verbäuche Nutzer
      mit verschiedenen Fahrzeugen erzielen und wie man im Vergleich zu anderen
      Nutzern seines Fahrzeugs abschneidet. Es kann Buch geführt werden über
      Kraftstoffkosten und bei Bedarf Wartung / Reparaturen. Vorausgesetzt man
      gibt entsprechende Daten bei den Betankungen / Ladevorgängen ein kann sich
      unter anderem auswerten lassen, in welchem Monat man welchen Verbrauch
      erzielt. </p>
    <p>Spritmonitor hat keine Beziehung zu soc_helper. </p>
    <h2><a id="mozTocId592205" class="mozTocH2"></a>Spritmonitor-Zugang
      verschaffen und Fahrzeug anlegen</h2>
    <p>Unter https://www.spritmonitor.de kann ein Nutzerkonto angelegt werden.
      Unter "Mein Account" kann ein (weiteres) Fahrzeug angelegt werden. Die ID
      (Nummer) dieses Fahrzeuges wird später gebraucht.</p>
    <h2><a id="mozTocId155224" class="mozTocH2"></a>Bearer-Token beschaffen und
      sichern</h2>
    <p>Für die Nutzung der Spritmonitor-Programmierschnittstelle durch ein
      Programm erfolgt keine Anmeldung per Passwort. Stattdessen wird ein
      App-Token und ein Bearer-Token verlangt. Das App-Token in configuration.py
      ist vorgegeben und sollte nicht geändert werden. Es signalisiert
      Spritmonitor, mit welcher App der Eintrag erfolgt. Das Bearer-Token ist
      nutzerindividuell und dient dazu, sich als Nutzer gegenüber Spritmonitor
      auszuweisen.</p>
    <p>Um sich ein Bearer-Token zu beschaffen, meldet man sich bei Spritmonitor
      an und navigiert auf diese Seite:<a href="%20https://www.spritmonitor.de/de/mein_account/passwort_aendern.html">
        https://www.spritmonitor.de/de/mein_account/passwort_aendern.html</a>
      (Von der Hauptseite: Mein Account-&gt;Passwort ändern). Dort kann man auf
      "Neuen Token erzeugen" klicken und bekommt ein Bearer-Token, das man sich
      auf seinen lokalen Rechner kopiert und gut sichert, weil es später nicht
      mehr angezeigt wird. Bei Verlust kann man ein neues Bearer-Token erzeugen
      lassen, muß dann aber eine Datei im homeverzeichnis ändern.</p>
    <h2><a id="mozTocId723519" class="mozTocH2"></a>Bearer-Token als
      Umgebungsvariable bereitstellen</h2>
    <p>Das Bearer-Token wird nicht in der Konfiguratiosdatei abgespeichert. Zu
      groß ist die Gefahr, daß es beim Veröffentlichen oder Weitergeben in
      fremde Hände gerät und dann Fremde auf den eigenen Spritmonitor-Zugang
      zugreifen können. Statt dessen wird das BEARER_TOKEN als Umgebungsvariable
      des Nutzers definiert, der den soc_helper laufen läßt. Diese Definition
      erfolgt in der (versteckten) Datei ~/.profile (Die Tilde ist eine
      Abkürzung für das home-Verzeichnis, ausgeschrieben also
      /home/pi/.profile). Diese Datei wird bei der Anmeldung an den Rechner
      ausgewertet. Es ist folgende Zeile ans Ende der .profile anzufügen:</p>
    <p><code>export SPRITMONITOR_BEARER_TOKEN=&lt;Token&gt;</code></p>
    <p>&lt;Token&gt; ist dabei die lange Zeichenkette aus dem vorigen Abschnitt.
      Wenn man sich nun neu auf dem pi anmeldet, auf dem der soc_helfer läuft
      und mit dem Befehl "export" die Umgebungsvariablen auflistet, sollte die
      Umgebungsvariable und ihr Inhalt zu sehen sein.</p>
    <p><code>pi@pi4:~$ export<br>
        declare -x DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/1000/bus"<br>
        declare -x HOME="/home/pi"<br>
        declare -x LANG="de_DE.UTF-8"<br>
        declare -x LOGNAME="pi"<br>
        declare -x MOTD_SHOWN="pam"<br>
        declare -x OLDPWD<br>
        declare -x
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games"<br>
        declare -x PWD="/home/pi"<br>
        declare -x SHELL="/bin/bash"<br>
        declare -x SHLVL="1"<br>
        <b>declare -x
          SPRITMONITOR_BEARER_TOKEN="vdfakognevlvthrneptnhreptnrehptnrezptzhepqutzhreqp"</b><br>
        declare -x SSH_CLIENT="2003:e0:171f:d200:1a36:79d:e3df:bbf 51302 22"<br>
        declare -x SSH_CONNECTION="2003:e0:171f:d200:1a36:79d:e3df:bbf 51302
        2003:e0:171f:d200:9d7:f4e0:527d:6594 22"<br>
        declare -x SSH_TTY="/dev/pts/0"<br>
        declare -x TERM="xterm-256color"<br>
        declare -x TEXTDOMAIN="Linux-PAM"<br>
        declare -x USER="pi"<br>
        declare -x XDG_RUNTIME_DIR="/run/user/1000"<br>
        declare -x XDG_SESSION_CLASS="user"<br>
        declare -x XDG_SESSION_ID="18410"<br>
        declare -x XDG_SESSION_TYPE="tty"<br>
        pi@pi4:~$ </code><br>
    </p>
    <p><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a></p>
    <h1><a id="mozTocId997138" class="mozTocH1"></a>OpenWB vorbereiten </h1>
    <p>Um mit dem WiCAN zusammen zu arbeiten, sind ein paar Einstellungen in der
      OpenWB nötig. An dieser Stelle erfolgt die Beschreibung für
      Software-Schiene 2, für Software 1.9 ist die Konfiguration ähnlich, aber
      deutlich einfacher. Es wird nur der Teil beschrieben, der für den
      soc_helper relevant ist.</p>
    <p>Für Software 2. Nur den für soc_helper relevanten Teil unter
      Konfiguration-&gt;Fahrzeuge<br>
    </p>
    <h2><a id="mozTocId676866" class="mozTocH2"></a>Fahrzeugprofile</h2>
    <p>Im zu nutzenden Fahrzeugprofil muß die Netto-Kapazität der
      Fahrzeugbatterie sowie der Ladewirkungsgrad korrekt eingestellt sein, da
      sonst das SoC-Modul während der Ladung den Ladezustand falsch berechnet
      (SoC bedeutet State of Charge und ist gleichbedeutend mit Ladezustand).
      Der e-Up! der zweiten Generation hat eine nutzbare Batteriekapazität von
      32,3kWh, dies wird hier gerundet. Beim Laden hat das Fahrzeug Verluste.
      Diese kommen einerseits von Nebenverbrauchern und sind unabhängig von der
      Ladeleistung, zum anderen hat das Ladegerät selbst von der Ladeleistungs
      abhängige Verluste. Die im Bild angegebenen 90% sind daher en Mittelwert.
      Wenn die Ladung mit geringer Leistung stattfindet, sind die Verluste
      höher, weil die Nebenverbraucher mehr ins Gewicht fallen. Bei hoher
      Leistung wird der Wirkungsgrade etwas besser sein. Hier gilt es, durch
      Probieren einen sinnvollen Wert herauszufinden:</p>
    <p>Wenn der SoC nach Abstecken grundsätzlich höher ist als von der Wallbox
      berechnet, sollte der Wirkungsgrad heraufgesetzt werden. Wenn der
      Ladezustand nach Abstecken meist zu niedrig ist, sollte der Wirkungsgrad
      verringert werden, um der Wirklichkeit Rechnung zu tragen.</p>
    <img src="OpenWB_Fahrzeugprofil.png" alt="" title="Einstellungen Fahrzeugprofil">
    <h2><a id="mozTocId955155" class="mozTocH2"></a>Fahrzeuge</h2>
    <p>Unter der Fahrzeugkonfiguration ist als SoC-Modul "Manueller SoC"
      auszuwählen. Dieses Modul nimmt normalerweise die manuelle Eingabe des SoC
      und rechnet anhand HV-Speicherkapazität, Ladewirkungsgrad und gemessener
      Ladearbeit den SOC während der Ladung fortwährend aus. Der soc_helper
      nutzt die Eingabemöglichkeit und schickt den aus dem Fahrzeug asugelesenen
      Ladezustand an die Wallbox, die dann während der Ladung den Fahrzeug-SoC
      berechnet.</p>
    <p>Der SoC wird nicht direkt aus dem Fahrzeug gelesen - das klappt nur mit
      der OpenWB Pro im Zusammenspiel mit einigen Fahrzeugtypen. Während der
      Ladung soll jede Minute der SoC aktualisiert werden, ohne Ladung ist es
      nicht nötig (lange ZZeitintervalle, hier 720 Minuten) und im abgesteckten
      Zustandergibt die Funktion keinen Sinn, daher nur aktualisieren wenn
      angesteckt.</p>
    <p><img src="OpenWB_EinstellungenFahrzeug.png" alt="" title="Fahrzeug-Einstellungen"></p>
    <h2><a id="mozTocId504076" class="mozTocH2"></a>Geräte-IDs herausfinden und
      merken</h2>
    <p>Die IDs (Nummern) der in der Wallbox konfigurierten Geräte sind wichtig
      für die Konfiguration des soc_helper. Die IDs sind übersichtlich auf der
      Statusseite der Wallbox aufgeführt:</p>
    <p><img src="OpenWB_Status.png" alt="" title="Statusseite der OpenWB in Software 2.x"><br>
    </p>
    <p>Für den soc_helper sind die ID der verwendeten Wallbox (im Bild "Interne
      openWB", ID 3) und die Nummer des Fahrzeugs, das den WiCAN verwendet
      ("Nulli", ID 1) wichtig. Diese Nummern sind im folgenden Kapitel wichtig.</p>
    <p><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a> </p>
    <br>
    <h1><a id="mozTocId36262" class="mozTocH1"></a>soc_helper konfigurieren</h1>
    <p>Alle Konfigurationsmöglichkeiten befinden sich in der Datei
      configuration.py. Das automatische Neueinlesen der Datei bei Änderungen
      wurde entfernt, da dieser Mechanismus zum Beispiel das Löschen und
      Neuanlegen der Datei nicht unterstützt hat und entfernte Variablen im
      Kontext des Hauptprogrammes nicht gelöscht wurden.</p>
    <h2><a id="mozTocId230049" class="mozTocH2"></a>Anlegen der Fahrzeuge</h2>
    <p>Zu Beginn con configuration.py wird jeweils eine leere Liste von
      Fahrzeugen ("myCars") und Ladepunkten ("myChargepoints") definiert. Ein
      Fahrzeug wird definiert, indem ein neuer Eintrag an diese Liste angehängt
      wird:</p>
    <code>myCars.append(cars.eUp(<br>
      &nbsp;&nbsp;&nbsp; name = "nulli",<br>
      &nbsp;&nbsp;&nbsp; openwbVehicleId = 1,<br>
      &nbsp;&nbsp;&nbsp; useSpritmonitor = True,<br>
      &nbsp;&nbsp;&nbsp; spritmonitorVehicleId =&nbsp; 1370192,<br>
      &nbsp;&nbsp;&nbsp; spritmonitorFuelsort = 24,<br>
      &nbsp;&nbsp;&nbsp; spritmonitorFuelprice = 0.08,<br>
      &nbsp;&nbsp;&nbsp; spritmonitorAttributes = 'summertires,slow'<br>
      ))<br>
    </code><code></code>
    <p>Die Fahrzeugdefinitionen befinden sich in cars.p, die verfügbaren Typen
      sollten als Kommentar in configuration.py gelistet sein. Das Beispiel
      hängt der Liste ein Fahrzeug vom Typ eUp an. Diesem Fahrzeug werden
      mindestens der Parameter <code>name</code> und <code>openwbVehicleId</code>
      mit korrekten Werten übergeben.</p>
    <ul>
      <li><code> name</code> ist der Name, der dem zugehörigen WiCAN bei der
        Konfiguration gegeben wurde (<a href="#mozTocId822299">Kapitel der
          WiCAN-Konfiguration</a>).</li>
      <li><code>openwbVehicleId</code> ist die Fahrzeug-ID, die auf der
        OpenWB-Statusseite gelistet ist.</li>
    </ul>
    <p>Fall ein Konto bei <a href="https://www.spritmonitor.de" title="Spritmonitor-Hauptseite"
        target="_blank">spritmonitor.de</a> besteht, können Ladevorgänge nach
      Beenden automatisch dort hochgeladen werden. Erforderlich ist ein Konto
      und die Anlage des Fahrzeugs dort.Für die Anbindung von Spritmonitor sind
      folgende weitere Parameter erforderlich:</p>
    <ul>
      <li><code>useSpritmonitor</code> muss True sein, damit Spritmonitor
        genutzt wird</li>
      <li><code>spritmonitorVehicleId </code>ist die Fahrzeugnummer, mit der
        das Fahrzeug bei Spritmonitor gelistet ist</li>
      <li><code>spritmonitorFuelsort </code>ist die Kraftstoffart, die per
        Default in den Betankungsvorgang eingetragen wird: 19 steht für
        allgemeinen Strom, 24 für Ökostrom.</li>
      <li><code>spritmonitorFuelprice</code> ist der Default-Kraftstoffpreis pro
        kWh. Dies kann der Bezugspreis sein oder bei eigener PV im Sommer die
        entgangene Einspeisevergütung. Sinnvoll kann bei eigener PV-Anlage auch
        der Gestehungspreis sein (Anlagenpreis geteilt durch Stromerzeugung über
        Lebensdauer)</li>
      <li><code>spritmonitorAttributes</code> ist eine Zeichenkette, in der
        durch Komma getrennt, Informationen über das Fahren zwischen den
        Tankvorgängen übergeben werden. Es sollten nur solche Attribute
        angegeben werden, die nahezu immer aktiv sind. Gültige Werte sind je ein
        Wort für Reifensorte ("summertires" / "wintertires" / "allyeartires"),
        die Fahrweise ("slow" / "normal" / "fast"), falls die Klimaanlage meist
        in Betrieb ist "ac", falls immer mit Anhänger gefahren wird "trailer",
        falls die Standheizung immer aktiv ist "heating". Die Zeichenkette darf
        leer sein ('').</li>
    </ul>
    <p>Bei der Übertragung wird für den Ladevorgang automatisch angewählt, daß
      mit 11kW AC geladen wurde und die Lademenge durch die Wallbox gemessen
      wurde. Momentan ist dies hart codiert. Falls Bedarf besteht, die
      Ladeleistung auf beispielsweie 3,6kW zu setzen (fixes Einphasiges Laden
      als Defaulteinstellung), kann ich den Wert konfigurierbar gestalten. Eine
      Berechnung der durchschnittlichen Ladeleistung halte ich für nicht
      sinnvoll, da eine Ladung für den soc_helper mit Stecken des Ladesteckers
      beginnt und mit Abziehen endet, auch wenn schon lange vorher kein Strom
      mehr geflossen ist.<a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a></p>
    <p>Anlegen eines weiteren Fahrzeugs vom Typ VW MEB ohne
      Spritmonitor-Anbindung:</p>
    <code>myCars.append(cars.VwMEB(<br>
      &nbsp;&nbsp;&nbsp; name =
      "Standard",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      # Name des Fahrzeugs, wie im WiCAN konfiguriert. Definiert einen Zweig
      unter others/ im MQTT-Broker.<br>
      &nbsp;&nbsp;&nbsp; openwbVehicleId =
      0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      # Fahrzeugnummer in der OpenWB-Konfiguration<br>
    </code>
    <p><code>))</code></p>
    <h2><a id="mozTocId304700" class="mozTocH2"></a>Anlegen der Ladepunkte</h2>
    <p>Das Anlegen der Ladepunkte, die vom soc_helper genutzt werden sollen
      erfolgt noch einfacher: Für jeden Ladepunkt wird lediglich die
      Ladepunktnummer übergeben:</p>
    <p><code>myChargepoints.append(chargepoints.chargepoint(chargepointId=3))</code></p>
    <h1><a id="mozTocId347587" class="mozTocH1"></a>soc_helper starten und
      stoppen</h1>
    <p>Für diesen Schritt muß immer eine Anmeldung auf dem Raspi erfolgt sein
      und mit</p>
    <p><code>pi@pi4:~/$ </code> <code>cd soc_helper</code></p>
    <p><code></code>in das Verzeichnis des soc_helper gewechselt werden. </p>
    <h2><a id="mozTocId985445" class="mozTocH2"></a>Programm im Vordergrund
      starten und stoppen</h2>
    <p>Für erste Tests ist es sinnvoll,den soc-Helper nicht im Hintergrund zu
      starten. Auf diese Weise sieht ma die Ausgaben des soc_helpers auf der
      Konsole.</p>
    <p><code>pi@pi4:~/soc_helper$ ./soc_helper.py</code></p>
    <p>Auf einen Fallstrick in Verbindung mit Windows auf dem Desktop-Rechner
      wird <a href="#mozTocId102185">hier</a> hingewiesen. Wenn die Dateirechte
      nicht richtig sind, kann trotzdem mit <code>python ./soc_helper.py </code>gearbeitet
      werden. </p>
    <h2><a id="mozTocId156538" class="mozTocH2"></a>Programm im Hintergrund
      laufen lassen</h2>
    <p>Um den soc_helper mit dem Abmelden nicht zu beenden, wird der Befehl
      nohup ("no hangup") verwendet.</p>
    <p><code>pi@pi4:~/soc_helper$ nohup ./soc_helper.py&amp;</code></p>
    <p>Das kaufmännische &amp; am Ende bewirkt, daß der Prozess von der Konsole
      gelöst wird und im Hintergrund weiterarbeitet. Damit ist die Konsole frei
      für weitere Eingaben, zum Beispiel die Ansicht der Ausgaben mittels tail:</p>
    <p><code>pi@pi4:~/soc_helper$ tail nohup.out <br>
        2024-05-02 15:14:21,799;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:245
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] WiCAN-Status:
        others/wican/nulli/status b'{"status": "offline"}'<br>
        2024-05-02 15:14:21,800;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:261
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] Fahrzeugstatus
        ist nicht &lt;&lt;online&gt;&gt;<br>
        2024-05-02 16:37:51,714;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:245
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] WiCAN-Status:
        others/wican/nulli/status b'{"status": "online"}'<br>
        2024-05-02 16:37:51,714;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:251
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] Fahrzeug ist
        online. Sende SOC- und DST-Anforderung<br>
        2024-05-02 16:37:51,715;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:254
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] Sende
        SOC-Anforderung: { "bus": "0", "type": "tx", "frame": [{ "id": 2021,
        "dlc": 8, "rtr": false, "extd": false, "data": [3, 34, 2, 140, 170, 170,
        170, 170] }] }<br>
        2024-05-02 16:37:51,716;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:258
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] Sende
        DST-Anforderung: { "bus": "0", "type": "tx", "frame": [{ "id": 2021,
        "dlc": 8, "rtr": false, "extd": false, "data": [3, 34, 2, 189, 170, 170,
        170, 170] }] }<br>
        2024-05-02 16:37:51,762;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:334
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        cb_rx() ] Fahrzeug-SOC ist 75<br>
        2024-05-02 16:37:51,803;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:344
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        cb_rx() ] Fahrzeug-Kilometerstand ist 10481<br>
        2024-05-02 16:42:09,821;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:245
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] WiCAN-Status:
        others/wican/nulli/status b'{"status": "offline"}'<br>
        2024-05-02 16:42:09,821;&nbsp;&nbsp;&nbsp;&nbsp;
        INFO;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc_helper.py:261
        -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb_status() ] Fahrzeugstatus
        ist nicht &lt;&lt;online&gt;&gt;<br>
      </code></p>
    <p>In die Datei nohup.out werden alle Augaben eines Prozesses geschrieben,
      der mittels nohup gestartet wurde.<br>
    </p>
    <h2><a id="mozTocId104512" class="mozTocH2"></a>Stoppen eines nicht im
      Hintergrund laufenden soc_helper</h2>
    <p>Durch die Tastenkombination &lt;Strg&gt;+&lt;C&gt; wird der laufende
      Prozess abgebrochen.</p>
    <h2><a id="mozTocId134662" class="mozTocH2"></a>Stoppen eines im Hintergrund
      laufenden soc_helper</h2>
    <p></p>
    Ermitteln der Prozessnummer des soc_helpers:
    <p><code>pi@pi4:~/soc_helper$ ps ax | grep soc<br>
        &nbsp;&nbsp;&nbsp; 501 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Ss&nbsp;&nbsp;&nbsp;&nbsp; 0:22 /usr/sbin/thd --triggers
        /etc/triggerhappy/triggers.d/ --socket /run/thd.socket --user nobody
        --deviceglob /dev/input/event*<br>
        &nbsp;359528 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Sl&nbsp;&nbsp;&nbsp;&nbsp; 7:02 python3 ./soc_helper.py<br>
        &nbsp;365331 pts/0&nbsp;&nbsp;&nbsp; S+&nbsp;&nbsp;&nbsp;&nbsp; 0:00
        grep soc</code></p>
    <p>ps bedeutet process status und gibt die Status der laufenden Prozesse
      aus. die Optionen ax zeigen alle Prozesse (nicht nur die der aktuellen
      Sitzung) und zeigen sie mit der kompletten Aufrufzeile.&nbsp; Der
      senkrechte Struch leitet die Ausgabe auf das Kommando grep um, das nur
      Zeilen durchlässt, die die Zeichenkette "soc" beinhalten.</p>
    <p>Der Prozess mit der Nummer 359528 ist der zu beendende Prozess. (Die
      Nummer ist individuell und fast nie die gleiche, daher wie oben
      beschrieben nachsehen). Beenden des soc_helpers:<code><br>
      </code></p>
    <p><code><code>pi@pi4:~/soc_helper$ </code>kill 359528</code></p>
    <p>Die Prozessnummer ist dabei die oben ermittelte.</p>
    <p>Eleganter geht das oben Beschriebene mit dem Befehl "pkill". Hiermit
      können Prozesse nach Namen beendet werden. Um alle Prozesse, die im Aufruf
      ein "soc_helper" tragen zu beenden, gibt man einfach</p>
    <p><code>pi@pi4:~$ pkill -f soc_helper.py</code></p>
    <p>ein.<br>
    </p>
    <h2><a id="mozTocId533403" class="mozTocH2"></a>Optional: Starten des
      soc_helpers mit Start des System</h2>
    <p>Vorweg: Falls man sehr selten Stromausfälle hat und der Rechner, auf dem
      der soc_helper läuft, dauerhaft an ist, kann man den soc_helper per Hand
      starten. Etwas komfortabler ist es, wenn mit dem Systemstart der
      soc_helper gleich mitgestartet wird. Hier gibt es mehrere Alternativen:</p>
    <h3>cron</h3>
    <p>cron ist Systemdienst, das bestimmte Kommandos zu definierten Zeiten
      ausführt. In einer Tabelle namens crontab stehen dazu die nötigen
      Informationen. Von dieser Tabelle gibt es neben der Version für das System
      für jeden Nutzer eine. In der System-crontab werden solche Sachen wie die
      Prüfung nach Updates, das Aufräumen temporärer Dateien oder Log-Dateien
      aufgerufen.</p>
    <p>Ein Nutzer kann seine crontab mit dem Befehl <code>crontab -e </code>bearbeiten.
      In die Datei kann die Zeile</p>
    <p><code>@reboot . $HOME/.profile; $HOME/soc_helper/startAtBoot.sh<br>
      </code></p>
    <p>eingefügt werden<code>.</code> Damit wird bei Neustart die mitgelieferte
      Datei startAtBoot.sh ausgeführt, die den soc_helper nach 10s Verzögerung
      startet.Bitte&nbsp; darauf achten, dass das Executable-Bit von
      startAtBoot.sh und soc_helper.py gesetzt sind. Das ". $HOME/.profile" ist
      nötig, damit die in der Datei .profile definierte Variable
      SPRITMONITOR_BEARER_TOKEN vorhanden ist und das Hochladen bei Spritmonitor
      funktionieren kann.</p>
    <h3>Systemdienst für systemd</h3>
    <p>Ein Systemdienst ist prinzipiell einfach zu erstellen, erfordert aber das
      Anlegen einer Datei in einem Systemverzeichnis. Wer sich das zutraut,
      findet unter <a href="https://forum.openwb.de/viewtopic.php?p=111670#p111670">diesem
        Link</a> eine hilfreiche Anleitung.</p>
    <p><code></code><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a></p>
    <p><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102"></a></p>
    <p></p>
    <ol>
    </ol>
    <div style="left: 1708px; top: 1795.85px; height: 2087.5px;">
      <h1>Hinzufügen neuer Fahrzeugtypen</h1>
      <p>Dein Fahrzeug ist noch nicht unterstützt? Dann bist du hier richtig.
        Für das zu unterstützende Fahrzeug müssen Informationen für die
        OBD2-Kommunikation vorliegen. Die Projekte<a href="https://github.com/nickn17/evDash">
          evDash</a> und <a href="https://github.com/EVNotify/EVNotify">EVNotify</a>
        haben schon für einige Fahrzeuge die OBD-Kommuikation hinterlegt.</p>
      <p>Ganz wichtig: Nach erfolgreichem Hinzufügen eines bisher nicht
        unterstützten Fahrzeugs schickt mir bitte die Konfiguration unter <a href="mailto:soc_helper@vortagsmett.de">soc_helper@vortagsmett.de</a></p>
      <p>Die Fahrzeuge sind in der Datei cars.py definiert. Die Datei enthält
        eine übergreifende Klasse carclass, die Variablen und Funktionen
        besitzt, die für jedes Fahrzeug gleich sind. Weiter unten folgen die
        Klassen der einzelnen Fahrzeugtypen. Diese erben alle Eigenschaften der
        carclass-Klasse und definieren darüber hinaus die Abfageparameter für
        SOC und Kilometerstand des jeweiligen Fahrzeugtyps. Auch die Berechnung
        von SoC und Kilometerstand aus den Antworten ist in diesen Klassen
        definiert.Die Abfrage von Werten über die CAN-Schnittstelle der
        OBD-Buchse erfolgt, indem eine Anfrage (Request ) an eine festgelegte
        Steuergeräte-ID geschickt wird. Das Steuergerät antwortet (Response)
        dann mit einer anderen ID und den zu der Anfrage gehörigen Datenbytes.
        Der WiCAN übermittelt die genannten Werte im json-Format, daher müssen
        diese noch in einen String vom json-Format verpackt werden.</p>
      <p> </p>
      <h2>SOC-Abfrage</h2>
      <code>self.SOC_REQ_ID = 2021<br>
        self.SOC_RESP_ID = 2029<br>
        self.SOC_REQ_DATA = [3, 34, 2, 140, 170, 170, 170, 170] self.SOC_REQUEST
        = '{ "bus": "0", "type": "tx", "frame": [{ "id":
        '+str(self.SOC_REQ_ID)+', "dlc": 8, "rtr": false, "extd": false, "data":
        '+str(self.SOC_REQ_DATA)+' }] }'</code>
      <p>Es gibt Steuergeräte-IDs mit 11 Bit Länge und erweiterte IDs mit 29 Bit
        Länge. Wird eine lange ID verwendet, ist im json-String das <code>false</code>
        hinter <code>"extd" <span style="font-family: serif;">durch ein True
            zu ersetzen!</span></code></p>
      <h2><a id="mozTocId44611" class="mozTocH2"></a>Kilometerstand-Abfrage</h2>
      <code>&nbsp;self.ODO_REQ_ID = 2021<br>
        &nbsp;self.ODO_RESP_ID = 2029<br>
        &nbsp;self.ODO_REQ_DATA = [3, 34, 2, 189, 170, 170, 170, 170]<br>
        &nbsp;self.ODO_REQUEST = '{ "bus": "0", "type": "tx", "frame": [{ "id":
        '+str(self.ODO_REQ_ID)+', "dlc": 8, "rtr": false, "extd": false, "data":
        '+str(self.ODO_REQ_DATA)+' }] }'</code>
      <p>Es gibt Steuergeräte-IDs mit 11 Bit Länge und erweiterte IDs mit 29 Bit
        Länge. Wird eine lange ID verwendet, ist im json-String das <code>false</code>
        hinter <code>"extd" <span style="font-family: serif;">durch ein True
            zu ersetzen!</span></code></p>
      <h2><a id="mozTocId395377" class="mozTocH2"></a>SOC-Berechnung</h2>
      <p>Jede Fahrzeugklasse muß eine Umrechnungsfunktion haben, die bei Aufruf
        eine Liste <code>bytes</code> von Zahlen empfängt und daraus den SoC
        berechnet und in der Variable self.soc abspeichert.</p>
      <code>&nbsp;&nbsp;&nbsp; def calcSOC(self, bytes):<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logging.debug(f'Daten für
        SoC-Berechnung: {bytes}')<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.soc =
        round(bytes[4]/2.5*51/46-6.4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        # VW e-up [2029, 98, 2, 140, aa, xx, xx, xx, xx].</code>
      <h2><a id="mozTocId299402" class="mozTocH2"></a>Kilometerstand-Berechnung</h2>
      <p>Jede Fahrzeugklasse muß eine Umrechnungsfunktion haben, die bei Aufruf
        eine Liste <code>bytes</code> von Zahlen empfängt und daraus den
        Kilometerstand berechnet und in der Variable self.odo abspeichert.</p>
      <p>FIXME: continue</p>
      <code>&nbsp;&nbsp;&nbsp; def calcODO(self, bytes):<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logging.debug(f'Daten für
        ODO-Berechnung: {bytes}')<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.odo =&nbsp;
        bytes[5]*65536+bytes[6]*256+bytes[7] # VW e-up. [2029, 98, 2, 189, xx,
        bb, cc, dd, xx, xx]</code><br>
      <br>
      <code></code><a href="./Inbetriebnahme%20soc_helper.html#mozTocId505102">zurück</a>
      <h1><a id="mozTocId979530" class="mozTocH1"></a>Optional, aber hilfreich:
        MQTT-Explorer auf Desktop installieren</h1>
      <p>Um im Fehlerfall den Grund herauszufinden, ist der MQTT-Explorer
        hilfreich. Dieser zeigt alle Topics eines MQTT-Brokers an, so dass
        nachzuvollziehen ist, ob zum Beispiel eine Botschaft nicht gesendet
        wurde oder der Empfänger sie nicht wahrgenommen hat.</p>
      <h2><a id="mozTocId797585" class="mozTocH2"></a>Oberfläche</h2>
      <h3>Beschaffung:</h3>
      <h3>Einrichten der Verbindung zur OpenWB</h3>
      <p>Links oben unter "Connections" das Plus-Symbol klicken. Dann die auf
        der rechten Seite zu sehenden Informationen und Schalterstellungen
        eingeben. Die Adresse der OpenWB natürlich auf die eigene Wallbox
        anpassen.</p>
      <p><img src="file:///home/zut/programmieren/Inbetriebnahme_soc_helper/MQTT-Explorer_Anmeldung.png"
          alt="Anmeldefenstzer des MQTT-Explorers" title="Anmeldefenster"></p>
      <br>
      <h3>Botschaften ansehen</h3>
      <p>Im linken Bereich des Fenster sind empfangen Botschaften zu sehen. Die
        kleinen Pfeile klappen die einzelnen Zweige der Hierarchie auf und zu.
        Im Bild aufgeklappt zu sehen ist die Statusbotschaft des WiCAN, mit der
        er sich schlafen gelegt hat.<br>
      </p>
      <img src="MQTT-Explorer_Hauptfenster.png" alt="Hauptfenster" title="Hauptfenster des MQTT-Explorers">
      <h3>Botschaften senden</h3>
      <p>Im vorigen Bild auf der rechten Seite zu sehen ist der Abschnitt
        "Publish". Unter Topic kann das MQTT-Topic eingegeben werden, unter dem
        Daten veröffentlicht werden sollen. In dem Kasten darunter können diese
        Daten eingegeben werden. Der Knopf "Publish" sendet diese Daten unter
        dem angegebenen Topic an den Broker der Wallbox.</p>
      <h2><a id="mozTocId440211" class="mozTocH2"></a>Nutzen des MQTT-Explorers
        zur Fehlersuche</h2>
      <p><br>
      </p>
    </div>
    <p><br>
    </p>
  </body>
</html>
